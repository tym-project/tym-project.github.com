<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: script | Tym-Project]]></title>
  <link href="http://blog.tym-project.fr/blog/categories/script/atom.xml" rel="self"/>
  <link href="http://blog.tym-project.fr/"/>
  <updated>2014-06-22T16:21:03+00:00</updated>
  <id>http://blog.tym-project.fr/</id>
  <author>
    <name><![CDATA[Tym]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Envoyer un e-mail via Gmail en ligne de commande]]></title>
    <link href="http://blog.tym-project.fr/2010/08/25/mail-avec-gmail-dans-un-script/"/>
    <updated>2010-08-25T11:59:21+00:00</updated>
    <id>http://blog.tym-project.fr/2010/08/25/mail-avec-gmail-dans-un-script</id>
    <content type="html"><![CDATA[<p>Gmail, on le sait tous, est un outil très
répandu. Souvent même dans le monde de l'entreprise avec Google Apps. Pourquoi
alors ne pas l'utiliser pour envoyer des alertes, logs ou autres sauvegardes
depuis un serveur Linux ? Allons-y...</p>

<!-- more -->


<p>Pour envoyer un e-mail depuis un script
il-y-a en général un passage obligé : un serveur SMTP en local. Hum, trop peu
pour moi, surtout pour envoyer un log tous les mois ! Heureusement <code>Esmtp</code> est
là. C'est un outil formidable et simplissime qui n'a qu'un seul rôle : servir
de relais STMP. Autrement dit, il est incapable d'envoyer un e-mail
directement, mais seulement de le transmettre à un autre serveur SMTP.</p>

<h2>La base : ESMTP</h2>

<p>Commencez par installer le package (ici sur Debian/Ubuntu) :</p>

<pre><code>apt-get install esmtp
</code></pre>

<p>Créez, si il
n'existe pas, le fichier <code>~./esmtprc</code> et changez ses droits :</p>

<pre><code>touch ~/.esmtprc
chmod 0700 ~/.esmtprc
</code></pre>

<p>Passons au contenu du fichier, je le rappelle, propre à Gmail :</p>

<pre><code>#file ~/.esmtprc
identity example@gmail.com
    hostname smtp.gmail.com:587
    username "example@gmail.com"
    password "p@ssw0rd"
    starttls required
</code></pre>

<p>Gmail utilisant tls (ssl),
il va vous falloir obtenir le certificat qu'il utilise. On va donc récupérer
les principaux certificats utilisés sur le web, avec <code>[man]curl[/man]</code> :
{% codeblock lang:bash %}
apt-get install curl
mkdir ~/.authenticate
chmod 700 ~/.authenticate
curl http://curl.haxx.se/ca/cacert.pem >~/.authenticate/ca.pem
chmod 600 ~/.authenticate/ca.pem
{% endcodeblock %}
<em>Attention à bien mettre les bons droits
sur les répertoires, sans quoi cela ne fonctionnera pas (plus de détails dans
la suite).</em></p>

<h2>Et pour envoyer un bête mail ?</h2>

<p>Un simple script fera l'affaire :
{% codeblock lang:bash %}</p>

<h1>!/bin/bash</h1>

<h1>Entête du message</h1>

<p>echo "To: copain@example.com Subject: Test de mail From:example@gmail.com " > /tmp/mail</p>

<h1>Corps du message</h1>

<p>echo "Salut copain, je t'envoie un e-mail !" >> /tmp/mail</p>

<h1>Envoie du message</h1>

<p>esmtp -tv &lt; /tmp/mail
{% endcodeblock %}
<code>[man]esmtp[/man]</code>
prends ici deux options : <code>-t</code> pour lire l'entête, <code>-v</code> pour le mode verbeux.
Si tout se passe bien vous obtiendrez une sortie dans ce style... et un e-mail
à l'autre bout bien entendu :</p>

<pre><code>Connected to MTA
StartTLS OK (128 bits)
From example@gmail.com: 250 OK k7sm4581630wej.2
To copain@example.com: 250 OK k7sm4581630wej.2
Message data: .
Message sent: 250 OK 1280951004 k7sm4581630wej.2
Disconnected to MTA
</code></pre>

<p>Sinon, rappelez vous des droits sur les certificats :</p>

<pre><code>Connected to MTA
StartTLS extension not supported by MTA
Disconnected to MTA
0 (null)
example@gmail.com: 0 (null)
</code></pre>

<h2>Et avec une pièce jointe ?</h2>

<p>Dans ce cas je n'ai pas, pour le moment, trouvé d'autre solution que
d'installer <code>[man]sendmail[/man]</code> avant tout. Il va servir d'interface, en
tant que daemon, avec Esmtp.</p>

<pre><code>apt-get install sendmail
</code></pre>

<h3>Une Perl</h3>

<p>vous pouvez utiliser un script Perl par exemple :</p>

<p>{% codeblock lang:perl %}</p>

<h1>!/usr/bin/perl -w</h1>

<p>use strict;
use warnings;
use MIME::Lite;</p>

<p>my $Message = new MIME::Lite</p>

<pre><code>From =&gt;'example@gmail.com',
To =&gt;'copain@example.com',
Subject =&gt;"Mon mail avec un fichier",
Type =&gt;'multipart/mixed';
</code></pre>

<p>$Message -> attach(</p>

<pre><code>Type =&gt; 'TEXT',
Data =&gt; "Voici le fichier",
);
</code></pre>

<p>$Message -> attach(</p>

<pre><code>Type =&gt; 'text/plain',
Path =&gt; "log.txt",
Filename =&gt; "log.txt",
);
</code></pre>

<p>$Message -> send;
{% endcodeblock %}
Attention ici aux type Mime (cf. <a href="http://www.sfsu.edu/training/mimetype.htm">Global MIME Types</a>) pour le fichier joint...</p>

<h3>Python !</h3>

<p>Ou du python (j'aime :)). On crée un module générique (source : <a href="http://snippets.dzone.com/posts/show/2038">Send email with attachment(s) in Python</a>) :
{% codeblock lang:python %}
import smtplib
import os
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.Utils import COMMASPACE, formatdate
from email import Encoders</p>

<p>def send_mail(send_from, send_to, subject, text, files=[],server="localhost"):</p>

<pre><code>assert type(send_to)==list
assert type(files)==list

msg = MIMEMultipart()
msg['From'] = send_from
msg['To'] = COMMASPACE.join(send_to)
msg['Date'] = formatdate(localtime=True)
msg['Subject'] = subject

msg.attach( MIMEText(text) )

for f in files:
    part = MIMEBase('application', "octet-stream")
    part.set_payload( open(f,"rb").read() ) Encoders.encode_base64(part)
    part.add_header('Content-Disposition', 'attachment; filename="%s"' %os.path.basename(f))
    msg.attach(part)

smtp = smtplib.SMTP(server)
smtp.sendmail(send_from, send_to, msg.as_string())
smtp.close()
</code></pre>

<p>{% endcodeblock %}
Et son appel :
{% codeblock lang:python %}
import my_send_mail
my_send_mail.send_mail("example@gmail.com",</p>

<pre><code>['copain@example.com'],
"Mon mail avec un fichier",
"Voici le fichier",['log.txt'])
</code></pre>

<p>{% endcodeblock %}
Bon envois ;-)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mettre en place un tunnel-proxy SSH autonome]]></title>
    <link href="http://blog.tym-project.fr/2010/03/19/mettre-en-place-un-tunnel-ssh-en-arriere-plan/"/>
    <updated>2010-03-19T13:00:43+00:00</updated>
    <id>http://blog.tym-project.fr/2010/03/19/mettre-en-place-un-tunnel-ssh-en-arriere-plan</id>
    <content type="html"><![CDATA[<p>Dans <a href="http://www.tym-project.fr/blog/2009/04/installer-un-serveur-ssh-destine-au-tunneling/">cet article</a> je
vous expliquais comment mettre en place un serveur servant à faire du
tunneling ssh. Mais quid de la partie client me direz vous ? Et bien c'est ce
dont il est question ici...</p>

<!-- more -->


<p>Je vais donc vous présenter un script que
j'utilise pour gérer un tunnel ssh permanent, en réutilisant les principes
d'authentification sans mot de passe. La première chose à faire est donc de
générer une paire de clés sur le client :</p>

<pre><code>ssh-keygen -t rsa
</code></pre>

<p>Comme habituellement, on copie la clé publique par un
quelconque moyen sur le serveur. Comme ici l'utilisateur <code>prox</code> ne possède pas
de mot de passe, on va passer par un autre compte. Il est déconseillé
d'utiliser le compte <code>root</code> directement, il faut donc passer par un user
normal. Voici par exemple une suite de commandes à exécuter :</p>

<pre><code>scp ~/.ssh/id_rsa.pub tym@server.chez-moi.com:~
ssh -p 443 tym@server.chez-moi.com
</code></pre>

<p>Puis sur le serveur, où l'on
passe en utilisateur <code>root</code> :</p>

<pre><code>su - cat id_rsa.pub &gt;&gt; /home/tun1/.ssh/know_hosts &amp;&amp; rm id_rsa.pub
</code></pre>

<p>Le serveur est maintenant prêt à nous authentifier sans mot de passe, il est
temps de se pencher sur le script client. La première fonction est celle qui
crée le tunnel. En l'occurrence dynamiquement sur le port 8080 :</p>

<p>{% codeblock lang:bash %}
function ssh_to_server(){</p>

<pre><code>/usr/bin/ssh -nN -D 8080 -p 443 tun1@server.chez-moi.com &amp;
echo $! &gt; /var/run/ssh_prox_pid
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Ce qui est intéressant ici c'est l'utilisation des options <code>n</code> et <code>N</code>
(<a href="http://www.delafond.org/traducmanfr/man/man1/ssh.1.html">source</a>) :</p>

<pre><code>-N
    N'exécute aucune commande distante. Utilisé pour les transferts de ports (seulement dans la version 2 du protocole). 
-n
    redirige l'entrée standard vers /dev/null (en fait, empêche la lecture depuis l'entrée standard). À utiliser lors d'une utilisation de ssh en arrière-plan. [...]
</code></pre>

<p>Donc l'utilisation de ces deux options en plus du "<code>&amp;</code>" (lancement dans un
processus fils) permettent de lancer le tunnel en arrière plan.</p>

<p>Afin que le script soit suffisamment robuste nous allons ajouter un peu plus
de code. Tout d'abord une fonction pour vérifier la bonne connectivité à
internet...inutile d'essayer d'ouvrir le tunnel pour rien :
{% codeblock lang:bash %}
function test_network(){</p>

<pre><code>ping -c 2 clubic.com
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Ensuite une fonction pour tester si le tunnel est déjà lancé ou non :
{% codeblock lang:bash %}
function test_prox(){</p>

<pre><code>ps aux | grep -v 'grep' | grep `cat /var/run/ssh_prox_pid`
</code></pre>

<p>}
{% endcodeblock %}
Ici
"<code>[man]grep[/man] -v grep</code>" sert à ne pas afficher le processus du <code>grep</code>, et
donc ne pas fausser le résultat (sinon il serait toujours positif, même sans
tunnel en route).</p>

<p>Et enfin le corps du script :
{% codeblock lang:bash %}
while :; do</p>

<pre><code>#Si le tunnel n'est pas déjà lancé
if ! test_prox ;then
    #Alors on teste si le réseau est bien connecté
    if test_network;then
        #Si oui ou ouvre le tunnel ssh_to_server
    else
        #Si non le script "dors" 5 secondes
        sleep 5
    fi
fi
</code></pre>

<p>done
{% endcodeblock %}
Il ne reste plus qu'a planifier le lancement du script au démarrage, en
utilisant <code>[man]crontab[/man]</code> par exemple :</p>

<pre><code># m h dom mon dow command @reboot /root/ssh_prox &amp;
</code></pre>

<p>Voici le code du script complet :
{% codeblock lang:bash %}</p>

<h1>!/bin/bash</h1>

<p>function ssh_to_server(){</p>

<pre><code>/usr/bin/ssh -nN -D 8080 -p 443 tun1@server.chez-moi.com &amp;
echo $! &gt; /var/run/ssh_prox_pid
</code></pre>

<p>}</p>

<p>function test_network(){</p>

<pre><code>ping -c 2 clubic.com
</code></pre>

<p>}</p>

<p>function test_prox(){</p>

<pre><code>ps aux | grep -v "grep" | grep `cat /var/run/ssh_prox_pid`
</code></pre>

<p>}</p>

<p>while :;do</p>

<pre><code>if ! test_prox ;then
    if test_network;then
        ssh_to_server
    else
        sleep  5
    fi
fi
</code></pre>

<p>done
{% endcodeblock %}
Bon bash ;-)</p>
]]></content>
  </entry>
  
</feed>
