<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: socks | Tym-Project]]></title>
  <link href="http://blog.tym-project.fr/blog/categories/socks/atom.xml" rel="self"/>
  <link href="http://blog.tym-project.fr/"/>
  <updated>2014-06-22T16:21:03+00:00</updated>
  <id>http://blog.tym-project.fr/</id>
  <author>
    <name><![CDATA[Tym]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Installation de ss5 sur une Debian 5]]></title>
    <link href="http://blog.tym-project.fr/2011/02/09/install-ss5-debian-et-script-init/"/>
    <updated>2011-02-09T12:00:48+00:00</updated>
    <id>http://blog.tym-project.fr/2011/02/09/install-ss5-debian-et-script-init</id>
    <content type="html"><![CDATA[<p><a href="http://ss5.sourceforge.net/">ss5</a> est un service de proxy SOCKS très
performant, développé par <a href="http://ss5.sourceforge.net/author.htm">une seule personne</a> je tiens à le souligner !
J'ai eu à l'installer sur une Debian 5, et j'ai donc réalisé un petit script
pour automatiser tout cela.</p>

<!-- more -->


<h2>On installe...</h2>

<p>N'oubliez pas de préciser le numéro de version complet dans la variable <code>VER</code>
:
{% codeblock lang:bash %}</p>

<h1>!/bin/bash</h1>

<p>VER="3.8.4-1"
DIR="/tmp/ss5_install"
apt-get update
apt-get -y install build-essential libpam0g-dev libpam-devperm libldap2-dev libssl-dev</p>

<p>if ! [ -d "$DIR" ];then mkdir $DIR fi
cd $DIR wget
http://downloads.sourceforge.net/project/ss5/ss5/$VER/ss5-$VER.tar.gz</p>

<p>tar xzf ss5-$VER.tar.gz</p>

<p>VER=<code>echo $VER | cut -d "-" -f 1</code></p>

<p>cd ss5-$VER</p>

<p>./configure --with-defaultport=80 &amp;&amp; make clean &amp;&amp; make &amp;&amp; make install
{% endcodeblock %}
Une particularité du <code>.tar.gz</code> de <code>ss5</code> c'est de ne pas intégrer le
numéro de sous-version ("-2" par exemple) dans le nom du dossier, ce qui
oblige à cette pirouette dans le script :</p>

<pre><code>VER=`echo $VER | cut -d "-" -f 1`
</code></pre>

<h2>...et on démarre !</h2>

<p>J'ai aussi créé un script pour <code>init.d</code> (assez basique), basé sur
<code>/etc/init.d/skeleton</code>. Il intègre quelques options comme le port par défaut
ou le lancement en mode daemon (<code>DAEMON_ARGS="-t -u root -b 0.0.0.0:80"</code>) :
{% codeblock lang:bash %}</p>

<h1>! /bin/sh</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides:          ss5</h1>

<h1>Required-Start:    $remote_fs</h1>

<h1>Required-Stop:     $remote_fs</h1>

<h1>Default-Start:     2 3 4 5</h1>

<h1>Default-Stop:      0 1 6</h1>

<h1>Short-Description: Initscript for ss5</h1>

<h1>Description:</h1>

<h3>END INIT INFO</h3>

<h1>PATH should only include /usr/* if it runs after the mountnfs.sh script</h1>

<p>PATH=/bin/:/usr/bin:/sbin:/usr/sbin
DESC="ss5 proxy server"
NAME=ss5
DAEMON=/usr/sbin/$NAME
DAEMON_ARGS="-t -u root -b 0.0.0.0:80"
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME</p>

<h1>Exit if the package is not installed</h1>

<p>[ -x "$DAEMON" ] || exit 0</p>

<h1>Load the VERBOSE setting and other rcS variables</h1>

<p>. /lib/init/vars.sh</p>

<h1>Define LSB log_* functions.</h1>

<h1>Depend on lsb-base (>= 3.0-6) to ensure that this file is present.</h1>

<p>. /lib/lsb/init-functions
#</p>

<h1>Function that starts the daemon/service</h1>

<p>#
do_start()
{</p>

<pre><code># Return
#   0 if daemon has been started
#   1 if daemon was already running
#   2 if daemon could not be started
start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test &gt; /dev/null \
    || return 1
start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \
    $DAEMON_ARGS \
    || return 2
</code></pre>

<p>}
#</p>

<h1>Function that stops the daemon/service</h1>

<p>#
do_stop()
{</p>

<pre><code># Return
#   0 if daemon has been stopped
#   1 if daemon was already stopped
#   2 if daemon could not be stopped
#   other if a failure occurred
start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME
RETVAL="$?"
[ "$RETVAL" = 2 ] &amp;&amp; return 2
# Wait for children to finish too if this is a daemon that forks
# and if the daemon is only ever run from this initscript.
# If the above conditions are not satisfied then add some other code
# that waits for the process to drop all resources that could be
# needed by services started subsequently.  A last resort is to
# sleep for some time.
start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON
[ "$?" = 2 ] &amp;&amp; return 2
# Many daemons don't delete their pidfiles when they exit.
rm -f $PIDFILE
return "$RETVAL"
</code></pre>

<p>}
case "$1" in
  start)</p>

<pre><code>[ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Starting $DESC" "$NAME"
do_start
case "$?" in
    0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;;
    2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;;
esac
;;
</code></pre>

<p>  stop)</p>

<pre><code>[ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Stopping $DESC" "$NAME"
do_stop
case "$?" in
    0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;;
    2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;;
esac
;;
</code></pre>

<p>  restart|force-reload)</p>

<pre><code>log_daemon_msg "Restarting $DESC" "$NAME"
do_stop
case "$?" in
  0|1)
    do_start
    case "$?" in
        0) log_end_msg 0 ;;
        1) log_end_msg 1 ;; # Old process is still running
        *) log_end_msg 1 ;; # Failed to start
    esac
    ;;
  *)
    # Failed to stop
    log_end_msg 1
    ;;
esac
;;
</code></pre>

<p>  *)</p>

<pre><code>echo "Usage: $SCRIPTNAME {start|stop|restart|force-reload}" &gt;&amp;2
exit 3
;;
</code></pre>

<p>esac
{% endcodeblock %}</p>

<p>Bonne installation ;-)</p>
]]></content>
  </entry>
  
</feed>
